Slider render()
    children  map    copy     emitMouse -> this.onMouseDown
    onMouseDown
        onStart
            found handle    onSlideStart      sets this.active.
            else handleRailAndTrackClicks.(maybe set this.active too?)
                getUpdatedHandles(curr, updateKey, updateValue, reversed)  // updateKey is curr handle to move.
                    submitUpdate





Handle
    onMouseDown   props.onMouseDown, props.emitMouse(e, id)
                                        which goes to slider.onMouseDown
    .. onTouchStart onKeyDown

Rail
    onMouseDown   props.onMouseDown, props.emitMouse(e)

Track
    onMouseDown   props.onMouseDown, props.emitMouse(e)


add mouseMove to Rail, track?    


///////
Why need to remove eventlisteners in mouseUp as well as componentwillunmount?

onStart has isTouch. Maybe use same style for onMouseMove/onTouchMove.   -- turn into onMove.
why does cloneElement send handles to element types other than Handles ?


// for tooltip:
don't do removeEventListener 'mousemove' in onMouseUp. Maybe just an isMouseDown.

Maybe instead add mouseEnter, mouseMove, mouseLeave as props for tracks, rails, handles.
    (so won't respond to mouseMove over tooltip itself as it currently does)
    For former, do current conversion. For handles, just use val of that handle.
    Style flag for 'grabbed' mode.


// for grippy:
handleRailAndTrackClicks  to cause onStart(e.handleId)    
        works except for custom mode demo - max separation of 100. 
        shouldn't grip if handle didn't move there.
        maybe just run through handles & check for pos ~ mouse pos bew? but after state change?
        also, with key focus, grippy should move key focus too.


todo: mouseEnter, mouseLeave - pass to rails, tracks, handles then back up to slider so handleid passed
    for onMove.
    Why doesn't mousedown over handle immediately show up as red?
    Think onStart should setState for preTooltipInfo.
        what's correct way to set state ? func vs just a call?


x    more robust to just pass handleId for tooltipPreInfo - (plus grabbed flag)
x        do all extraction of vals in render, since they are there anyhow in mappedHandles.

    then can easily set handleId in onStart.

    replace tooltipPreInfo { val: number, handle: {id: string, grabbed: boolean}}

   talkiv.     

tooltip: no emit mouse.

grab handle on its left. Move cursor 1px to right. Handle actually moves to left to center on cursor.
    maybe just move cursor to the center of handle when you click on it.

addMouseEvents only if mouseOver or actively grabbing. look again at orig.
    maybe have mouseMoveOnGadget to do the setHoverState, and only if mouse not down.
        then take out mouseIsDown from onMouseMove.

Can we do everything with mouseMoveGadget? Need mouseOverHandleId etc at all?        

dangerous mutual calling of onStart to handleRailAndTrackClicks

problem with not in grabbed state after track click: 
    active is set in onStart. But then handleRailAndTrackClicks not immediately called. 
    takes next onMove to do submitUpdate, and that will set tooltipInfo.

onMouseDown 
    onStart
        onSlideStart   setsActive   ** set grabbed here.
            or
        handleRailAndTrackClicks
            submitUpdate
                should then do an onslidestart
                tooltipInfo  grabbed   ** if 

x setTooltipInfo in different place than submitUpdate?

x rename setHoverState?
x onkeydown: tooltip.

xthis.active in state? want handleactive flag too.

xclick on handle. tooltip disappears on mouseup (and flicker on drag & up)
    x  cos onMouseUp -> setHoverState(null)
x    setHoverState now always setting false.

xtooltipInfo:    replace with activeHandleId in state?  -- used for handle styling
x            and hoveredHandleId in mouse events can then be used for styling too.
x                            does this rerender?


x grabbed tooltip state only showing on first click. any move reverts to nongrabbed.
x    onMouseUp to take e? - have to store it in last onMouseMove.

x eg track rerendering on hover. Did it do this on progress before? Think it must have. Would it with mobx/pure    

Ticks to be part of a more general nav-background. Allow hover / click to feed to standard track/rail treatment,
        but also allow overrides.

kill my todos
x Tooltip copy in build

setStates:
    startSlide
        onStart
            onMouseDown
            onTouchStart
        grabHandleIfOk

    grabHandleIfOk              // just for 
        handleRailAndTrackClicks
            onStart         
    setHoverState
    submitUpdate
        onKeyDown
        handleRailAndTrackClicks
        onMove  
    onMouseEnterGadget
    onMouseLeaveGadget
    endSlide




///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// My Changes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
noAutoSnap, noWarnOnSnap

clicking on track now grabs handle, but only if the handle can move there according to that mode

Tooltips are implemented following the same child component paradigm as Rail, Handle, etc. Should be pretty flexible,
    Examples shown as last item on the demo pages - horizontal, vertical, and material (but styling isn't material...)
    Different tooltip states for hover over rail/track, hover over handle, and attached to active handle during a slide.

In addition I did a fair bit of refactoring:
this.active was moved into state - this allows more flexibility for styling tooltip, and (soon) for
    differently styled active handle.
Touch/mouse handling has been further unified for DRY.
rewired setState stuff - needed it to be more functional especially for handles being captured by a rail click.
A couple of tweaks to the build system were needed for windows - won't work off windows though.


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// pr
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
This PR implements three features as discussed:

Handle position values are now automatically rounded to the appropriate step. This feature is on by default, but can be turned off with the noAutoSnap property. There's also a noWarnOnSnap flag provided. (I can't see any uses beyond the default behavior now, but the flags are there just in case. I didn't end up exposing the rounding function since the default system now seems robust enough.
I've tested the feature on my own projects that previously had rounding issues due to non-nice step-sizes and it works well. The RCS demo pages all have polite step values so didn't exhibit rounding problems anyhow.

Clicking on a track or rail now 'grabs' the handle that moves to the click point. However, if a handle can't reach that point due to the mode constraints, then nothing is grabbed. This works well on all sliders in the demo pages.

<Tooltip>'s are implemented following the same child component paradigm as <Rail>, <Handle>, etc, and should be fully flexible. I've added an example with tooltips to each of the demo pages - horizontal, vertical, and materialUi (though I didn't do any material styling on it...)
Tooltips exhibit different styles depending on whether the pointer is hovering over the rail/track, or hovering over a handle. While a handle is sliding, the tooltip is attached to that handle regardless of pointer position. Only this last tooltip is visible on a touch device.

In addition I did a fair bit of refactoring:
Mouse events over the rail/track/handle system (the 'gadget') are now passed back to the slider to be handled by onMouseEnterGadget etc.
Properties of Slider (eg this.active) have been moved into state - I needed this to provide the flexibility for styling tooltips and later I think it will more cleanly allow 's to be styled differently if they're active.
Touch/mouse handling has been further unified in accordance with DRY.
The setState logic has been rearranged. I needed it to be more functional, especially for the issue of grabbing handles after a rail click.
A couple of tweaks to the build system were needed for windows - won't work off windows though.

Other than that I've tried to maintain the current style. All unit tests are passing, though I didn't add any more. Performance seems fine, though I didn't benchmark it carefully. Touch events have only been tested in the Chrome simulator, but they seem ok there.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
Hi. This PR implements the three features we discussed:

1) Handle position values are now automatically rounded to the appropriate step, rather than generating a warning if they don't match. This feature is on by default, but can be turned off with the `noAutoSnap` property. There's also a `noWarnOnSnap` flag provided. (I can't see any uses beyond the default behavior now, but the flags are there just in case. I didn't end up exposing the rounding function since the default system now seems robust enough.
I've tested the feature on my own projects that previously had rounding issues due to non-nice step-sizes and it works well. The RCS demo pages all have polite step values so didn't exhibit rounding problems anyhow.

2) `MouseDown` on a track or rail now immediately 'grabs' the handle that moves to the click point. However, if a handle can't reach that point due to the mode constraints, then nothing is grabbed. This works well on all sliders in the demo pages.

3) `<Tooltip>`'s are implemented following the same child component paradigm as `<Rail>`, `<Handle>`, etc, and should be fully flexible. I've added an example with tooltips to each of the demo pages - horizontal, vertical, and materialUi (though I didn't do any material styling on that one...)
Tooltips exhibit different styles depending on whether the pointer is hovering over the rail/track, or hovering over a handle. While a handle is sliding, the tooltip is attached to that handle regardless of pointer position. Only this last tooltip type applies for touch events.

To implement these, I did a fair bit of refactoring:

- Mouse events over the rail/track/handle system (the 'gadget') are now passed back to `Slider` to be handled by `onMouseEnterGadget` etc.

- Properties of `Slider` (eg `this.active`) have been moved into `state` - I needed this to provide the flexibility for styling tooltips and later I think it will more cleanly allow `<Handle>`'s to be styled differently if they're active.

- There were some DRY opportunities in `Slider.js`, for example the further unification of touch/mouse handling.

- The `setState` logic has been rearranged. I needed it to be more functional, especially for the issue of grabbing handles after a rail click. I went through a couple of iterations to sort out some `setState` async issues but I think it's now pretty clean.

- A couple of tweaks to the build system were needed for windows - won't work off windows though.

Other than that I've tried to maintain the current style. All unit tests are passing, though I didn't add any more. Performance seems fine, though I didn't benchmark it carefully. Touch events have only been tested in the Chrome simulator, but they seem ok there.

Cheers.